### 1 java 执行过程

.java文件-->编译-->.class文件，编译成.class字节码，.class需要jvm解释，然后解释执行。

编译过程：

源代码-> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器



### Java是编译型语言还是解释型语言？

半解释半编译。首先由Javac将Java文件编译为class文件，然后由jvm解释执行



###  2 jvm的作用

保证Java一次编译到处运行，屏蔽了机器底层机器码。保证Java不面向任何的处理器而只是面向于虚拟机。



### 3 Hash为什么要右移16位异或？

```
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 }
```

**如果我们不做刚才移位异或运算，那么在计算index时将丢失高区特征**

使得hash更加分散

了解：如果采用**&**运算计算出来的值会向1靠拢，采用**|**运算计算出来的值会向0靠拢



### 3.2 为什么槽位数必须使用2^n？（美团）

1 为了让hash后的结果更加均匀

如果 length = 17 那么 hash & (17 - 1) 。16转化为二进制包含更多的0，这样一来计算会被更多的0屏蔽。

如果槽位是 17，那么最大的值16的二进制表示为： 0001 0000，然后会有很多的0

如果槽位是16，那么最大的值15的二进制表示为： 0000 1111 ，全是1 

2 便于扩容后的重新计算index。



### 为什么扩容时总是把capacity扩大为原来的2倍？

1 由于我们要维护hashmap的大小为2^n，这样就使得len-1的二进制中全部都是1。进行位运算时可以降低hash碰撞的出现。

位运算比取模速度快

2 便于扩容后的重新计算index。

### HashMap的负载因子为什么是0.75？（美团）

负载因子主要与扩容有关，如果将负载因子设置为1，空间利用的就更加充分了，但是这样一来**会增大hash碰撞**的出现，有些位置的链表会过长，不利于查找。如果设置的过小的话虽然降低了hash碰撞的发生，但是会频繁触发扩容机制。

所以为了折中，将负载因子设置为0.75是对空间与时间的取舍。





### 解决hash冲突的方法？（美团）

**1.拉链法（链地址）**：hashMap

**2.线性探测法：**冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

**3.二次探测法：**冲突发生时，在表的左右进行跳跃式探测，比较灵活。



### Java多线程编程时有哪几种线程间通信方式

1. **共享内存法**

   volatile，synchronized

2. **wait/notify机制**

   来自Object类的方法。当满足某种情况时A线程调用wait()方法放弃CPU时间片，并进入阻塞状态。当满足某种条件时，B线程调用notify()方法通知A线程。唤醒A线程，并让它进入可运行状态。

3. **Lock/Condition机制**

   Condition是Java提供了来实现**等待/通知**的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。



### G1

G1：填补了CMS的不足，是当前服务端最优的垃圾收集器。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。



### AQS原理

QS框架是用来构建锁的同步器框架,包括了常用的`ReentrantLock`,`ReadWriteLock`,`CountDownLatch`等都是基于AQS框架来实现的。

AQS使用一个FIFO队列表示排队等待锁的线程，队列头结点称作“哨兵节点”或者“哑结点”，它不与任何线程关联。其他的节点与等待线程关联，每个阶段维护一个等待状态waitStatus。

AQS中有一个表示状态的字段state，例如`ReentrantLock`用它来表示线程重入锁的次数，`Semphore`用它表示剩余的许可数量，`FutureTask`用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。



### GC root包含什么？

- 虚拟机栈空间中非静态变量表中引用的对象
- 本地方法栈中 `JNI` 中引用的对象
- 方法区中静态变量引用的对象
- 方法区中的常量引用的对象



### 类的加载过程？

1. 加载：加载class字节码文件
2. 验证：验证字节码文件中是否会拟机安全的
3. 准备：准备阶段为类变量分配内存并设置初始值，使用的是方法区（`jdk 1.8` 元空间实现）的内存。
4. 解析：将常量池的符号引用替换为直接引用的过程。
5. 初始化：初始化阶段才真正开始执行类中定义的 Java 程序代码。



### 双亲委任机制

某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次递归**，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

**优点**：

1. 避免类的重复加载
2. 保护程序安全，防止核心`API`被破坏。





### JVM常用的参数？

初始堆内存 -Xms

最大堆内存 -Xmx

元空间 -XX MetaSpaceSize

新生代初始内存 -XX NewSize

新生代最大内存 -XX MaxNewSize

设置栈内存：-Xss

新生代老年代比例

设置垃圾回收器

打印gc日志





### JVM 的永久代中会发生垃圾回收么

会，主要是**对常量池以及类**的卸载。对类的卸载需要满足三个条件。

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。





### 虚拟机栈包含什么

虚拟机栈空间以栈帧为基本单位

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟街运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的**局部变量表**、**操作数栈**、**动态链接**和**方法返回地址**等信息。每一个方法从调用开始到执行完成的过程，都是一个栈帧在虚拟机栈里面从出栈到入栈的过程。





### JAVA 内存模型

Java 内存模型试图**屏蔽各种硬件和操作系统的内存访问差异**，以实现让 `Java` 程序在各种平台下都能达到一致的内存访问效果。





### 线上生产如何尽量避免Full GC的出现

1,禁止使用system.gc（）他建议jvm进行full gc

2,减少大对象大数组的创建，让对象尽量在young gc回收





### 等待队列



```
LinkedBlockingQueue
SynchronousQueue
ArrayBlockingQueue;
```



### 线程池为什么这样设计吗

线程池这样设计实际上是构建了一个生产者消费者模型，它将线程和任务两者解耦，**从而良好的缓冲任务，复用线程。**线程池的运行分为两大部分，任务管理、线程管理。

任务管理充当生产者，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。

线程管理充当消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。



### 线程数的设置与IO时间以及cpu执行时间的一个关系

**阿姆达尔定律：**

设置的线程数 = CPU 核数 * (1 + IO time / CPU computing time)

举例说明，假设4核 CPU，每个任务中的 IO 任务占总任务的80%，CPU时间占用20%。则线程数应设置为：4 * (1 + 4) = 20个线程，这里的20个线程对应的是4核心的 CPU。

队列大小 = 线程数 * (目标相应时间/任务实际处理时间)等待队列一定要使用有界队列，否则会拖垮整个系统。



### 谈谈面向对象语言和面向过程语言的区别

**面向过程：**面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。

**面向对象：**面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。







## 2

### docker 是什么

Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。



### docker镜像是什么？



Docker镜像是Docker容器的源代码，Docker镜像用于创建容器。使用build命令创建镜像。



### docker容器是什么?



Docker容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。





## 3

ps -ef







cat 1.txt | wc -lwc
      1       1       5

l 行数

w 单词数

c 字节数









## 4



### 什么是SQL注入？如何防止？

是一种**注入攻击**，它通过将任意代码插入数据库查询，使得攻击者完全控制数据库服务器，还可以使用SQL注入来添加，修改和删除数据库中的记录。

**#{}是预编译处理，** **使用#{}可以有效的防止SQL注入**

${}是直接字符串替换



Mybatis 中优先使用 #{}。当需要**动态传入表名或列名**时，使用 ${} 





### Mysql 二级缓存

#### 一级缓存

MyBatis 的一级缓存是在会话（SqlSession）层面进行缓存的。MyBatis 的一级缓存是默认开启的，不需要任何的配置



不同的`sqlSession`中的缓存是互相不能读取的。当在同一个`sqlSession`中执行两次相同的select`sql`语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存）。



一级缓存的不足：

　　使用一级缓存的时候，因为缓存不能跨会话共享，不同的会话之间对于相同的数据可能有不一样的缓存。在有多个会话或者分布式环境下，会存在脏数据的问题。如果要解决这个问题，就要用到二级缓存。MyBatis 一级缓存（MyBaits 称其为 Local Cache）无法关闭，但是有两种级别可选：

1. session 级别的缓存，在同一个 sqlSession 内，对同样的查询将不再查询数据库，直接从缓存中。
2. statement 级别的缓存，避坑： 为了避免这个问题，可以将一级缓存的级别设为 statement 级别的，这样每次查询结束都会清掉一级缓存。



#### 二级缓存

二级缓存是用来解决一级缓存不能跨会话共享的问题的，范围是namespace 级别的，可以被多个SqlSession 共享（只要是同一个接口里面的相同方法，都可以共享），生命周期和应用同步。如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，

即MyBatis查询数据的顺序是：二级缓存  —> 一级缓存 —> 数据库。



二级缓存是mapper级别的缓存，多个`sqlSession` 去操作同一个mapper的`sql`语句，它们可以公用二级缓存，二级缓存是跨`sqlSession`的。



参考 https://www.cnblogs.com/wuzhenzhao/p/11103043.html





### MyBatis的运行步骤？

1. 创建 `SqlSessionFactory`
2. 通过 `SqlSessionFactory` 创建 `SqlSession`
3. 通过 `sqlsession` 执行数据库操作
4. 调用 session.commit()提交事务
5. 调用 session.close()关闭会话



### MyBatis的工作原理说一下

MyBatis先封装SQL，接着调用JDBC操作数据库，最后把数据库返回的表结果封装成Java类。

MyBatis也有四大核心对象：

1. `SqlSession`对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection。
2. Executor接口，它将根据`SqlSession`传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的`Statement/PrepareStatement`。
3. `MappedStatement`对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息。
4. `ResultHandler`对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型。





### MyBatis 详细工作流程

[![img](https://camo.githubusercontent.com/fe8aec218f524f9e4a2eea96485cf53399e6d338b578a3e98c7554585621c525/687474703a2f2f7777772e6d7962617469732e636e2f7573722f75706c6f6164732f323031392f31302f3332363531373634332e706e67)](https://camo.githubusercontent.com/fe8aec218f524f9e4a2eea96485cf53399e6d338b578a3e98c7554585621c525/687474703a2f2f7777772e6d7962617469732e636e2f7573722f75706c6f6164732f323031392f31302f3332363531373634332e706e67)

1. 读取`MyBatis`的配置文件。`mybatis-config.xml`为`MyBatis`的全局配置文件，用于配置数据库连接信息。
2. 加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在`MyBatis`配置文件`mybatis-config.xml`中加载。`mybatis-config.xml` 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
3. 构造会话工厂。通过`MyBatis`的环境配置信息构建会话工厂`SqlSessionFactory`。
4. 创建会话对象。由会话工厂创建`SqlSession`对象，该对象中包含了执行SQL语句的所有方法。
5. Executor执行器。`MyBatis`底层定义了一个Executor接口来操作数据库，它将根据`SqlSession`传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。
6. `MappedStatement`对象。在Executor接口的执行方法中有一个`MappedStatement`类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
7. 输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对`preparedStatement`对象设置参数的过程。
8. 输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。











`InnoDB`储存引擎标准实现的锁只有两种：**行级锁、意向锁**。

`InnoDB`实现了如下两种标准的行级锁：

- 共享锁（读锁 S Lock），允许事务读一行数据
- 排它锁（写锁 X Lock），允许事务删除一行数据或者更新一行数据

`InnoDB`支持两种意向锁（即为表级别的锁）：

- 意向共享锁（读锁 IS Lock），事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（写锁 IX Lock），事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

**加意向锁表明某个事务正在锁定一行或者将要锁定一行**。首先申请意向锁的动作是`InnoDB`完成的，怎么理解意向锁呢？例如：事务A要对一行记录r进行上X锁，那么`InnoDB`会先申请表的IX锁，再锁定记录r的X锁。在事务A完成之前，事务B想要来个全表操作，此时直接在表级别的IX就告诉事务B需要等待而不需要在表上判断每一行是否有锁。**意向排它锁存在的价值在于节约`InnoDB`对于锁的定位和处理性能。**

`InnoDB`有**3种行锁的算法**：

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，而非记录本身
- Next-Key Lock：结合Gap Lock和Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是RR隔离级别下的**幻读问题**。







 `InnoDB`储存引擎中，**聚簇索引就是按照每张表的主键构造一颗B+树**，**叶子节点中存放的就是整张表的行记录数据**，**也将聚簇索引的叶子节点称为数据页**。

非聚簇索引的叶子节点存储的是数据行的主键信息。



我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了寻找主键索引的**二级索引**，先找到主键索引再通过主键索引找数据







**聚簇索引的优点：**

- 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的排序查找和**范围查找**速度非常快

**聚簇索引的缺点：**

- 插入速度严重依赖于插入顺序，按照主键的**顺序插入**是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于`InnoDB`表，我们一般都会定义一个**自增的ID列为主键**
- 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于`InnoDB`表，我们一般定义主键为不可更新。
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。这种二次查询的方式叫做**回表查询**。





### B+树的特性？



1. 所有的非叶子节点只保存索引，不保存数据。因此树结构更加矮胖，减少磁盘I/O次数。
2. **对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。**



### 联合索引的数据结构





### explain查询到的字段



### 幻读



### redo undo log 的作用

rodo 重做  undo 撤销              bin log 是MySQL数据库的**二进制日志**，用于记录用户对数据库操作的SQL语句（(除了数据查询语句）信息。



redo log 常用作MySQL服务器异常宕机后的数据恢复工作，复杂保证事务的持久性

undo log 常用于记录被改动的数据，负责事务的一致性。

### 如何保证MySQL的主从强一致性



1. 在**主库**事务提交的时候，同时发起两个操作，操作一是将日志写到本地磁盘，操作二是将日志同步到从库并确保落盘。
2. **主库**此时等待两个操作全部成功返回之后，才返回给应用程序，事务提交成功。

强一致性导致的问题

事务的每次提交都需要等到从机的落盘完成后才可以提交。

### bin log 与 redo log 的区别?





1. bin log是MySQL级别的日志文件，无论使用哪种存储引擎都会生成。而redo log 是`innodb`引擎独有的日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败时，redo log文件就能派上用场，如数据库掉电，`InnoDB`存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。
2. 两种日志记录的内容形式不同。MySQL的bin log是逻辑日志，其记录是对应的SQL语句。而`innodb`存储引擎层面的重做日志是物理日志。
3. 两种日志与记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而`innodb`存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。
4. bin log可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。

### 索引

1. 单一索引：
2. 复合索引：根据创建联合索引的顺序，以**最左前缀匹配原则**进行where检索。
3. 覆盖索引：查询的字段与建立索引的字段一一对应就叫做覆盖索引。



### 当前读与快照读

在一个支持MVCC的系统中，读操作被分为当前读与快照读

快照读：简单的select操作，不加锁。

```
select * from table where ?;
```

当前读：插入/更新/删除操作，需要加锁

```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
```

### DDL与DML

- DML（data manipulation language）数据操纵语言：

　　　　就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。

- DDL（data definition language）数据库定义语言：

　　　　其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。**DDL主要是用在定义或改变表的结构**，数据类型，表之间的链接和约束等初始化工作上

### JDBC说一下

1. 通过驱动建立一个连接，这个连接代表着一个真实的数据库连接。
2. 由conn建立一个`Statement`或`PreparedStatement`对象。
3. `stmt.executeUpdate(sql)`执行语句，返回即查询解决。





### mvcc

其实也就是MVCC通过在每行纪录后面保存两个隐藏的列来实现的。一个保存了行的创建时间[实际存储的是版本号]、一个报存了行的过期时间(或删除时间)[实际存储的是版本号]

> **（即事务id为2的事务只能读取到create version<=2 或 delete version = 0 或 delete version > 2的已提交的事务的数据集）**

从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：（可以根据时间大小进行比较）
1) 删除版本号未指定或者大于当前事务版本号（其实可以根据时间的大小进行比较大的），即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。

## redis

### 为什么要用redis而不是map或者guava做缓存

使用map guava做缓存 在多实例的情况下，缓存不具有一致性，使用redis可以做到分布式缓存

  

### redis的内存淘汰策略有哪些



- `noeviction`：当内存不足以容纳新写入数据时，新写入操作会报错。
- `allkeys-lru`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是**最常用**的）
- `allkeys-random`：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- `volatile-lru`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- `volatile-random`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- `volatile-ttl`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

### 过期键的删除策略

定时过期

惰性过期

一般两者配合使用



### 持久化策略

RDB

AOF

### 	redis 线程模型

`redis`以**单线程**模式运行，但是通过使用 I/O 多路复用来监听多个套接字（socket）， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 `redis` 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 `Redis` 内部单线程设计的简单性。

### 秒杀中如何处理超卖问题

直接由数据库操作库存的sql语句如下所示。依靠MySQL中的排他锁实现

```
 update table_prmo set num = num - 1 WHERE id = 1001 and num > 0
```

**利用`redis`的单线程特性预减库存处理秒杀超卖问题！！！**

1. 在系统初始化时，将商品以及对应的库存数量预先加载到`Redis`缓存中；（缓存预热）
2. 接收到秒杀请求时，在`Redis`中进行预减库存（decrement），当`Redis`中的库存不足时，直接返回秒杀失败，否则继续进行第3步；
3. 将请求放入**异步队列**中，返回正在排队中；
4. 服务端异步队列（MQ）将请求出队，出队成功的请求可以生成秒杀订单，减少数据库库存，返回秒杀订单详情

###

###

###

###

###

###

###

###